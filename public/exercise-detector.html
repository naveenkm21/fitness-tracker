<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercise Detection Demo</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
        }
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        .video-container {
            position: relative;
            width: 640px;
            height: 480px;
            margin: 20px auto;
            border: 3px solid #333;
            border-radius: 10px;
            overflow: hidden;
            background-color: #000;
        }
        video, canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        .controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .results {
            width: 640px;
            margin: 0 auto;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .exercise-status {
            font-size: 24px;
            font-weight: bold;
            margin: 20px 0;
        }
        .rep-counter {
            font-size: 48px;
            font-weight: bold;
            color: #4CAF50;
        }
        .loading {
            margin: 20px 0;
        }
        .model-selector {
            margin: 20px 0;
        }
        .debug-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #f0f0f0;
            border-radius: 5px;
            text-align: left;
            font-family: monospace;
            font-size: 12px;
            max-height: 150px;
            overflow-y: auto;
        }
        .user-info {
            margin: 20px 0;
            padding: 15px;
            background-color: #e8f5e9;
            border-radius: 10px;
            width: 640px;
        }
        .xp-bar {
            width: 100%;
            height: 20px;
            background-color: #ddd;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        .xp-progress {
            height: 100%;
            background-color: #4CAF50;
            width: 0%;
            transition: width 0.5s ease-in-out;
            border-radius: 10px;
        }
        .xp-text {
            font-weight: bold;
            margin-bottom: 5px;
        }
        .level-display {
            font-size: 36px;
            font-weight: bold;
            color: #2E7D32;
            margin: 10px 0;
        }
        .milestone {
            margin: 15px 0;
            padding: 10px;
            background-color: #fff9c4;
            border-radius: 5px;
            font-weight: bold;
            display: none;
        }
        .arm-selector {
            margin: 15px 0;
        }
        .leaderboard-export {
            margin-top: 20px;
            padding: 15px;
            background-color: #e3f2fd;
            border-radius: 10px;
            width: 640px;
        }
        .feedback-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .correct-form {
            background-color: rgba(76, 175, 80, 0.3);
        }
        .incorrect-form {
            background-color: rgba(244, 67, 54, 0.3);
        }
        .achievement {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: #3f51b5;
            color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transform: translateX(200%);
            transition: transform 0.5s ease-out;
            z-index: 1000;
        }
        .show-achievement {
            transform: translateX(0);
        }
        /* Save and Exit button styling */
        .save-exit-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #f44336;
            color: white;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            transition: background-color 0.3s;
        }
        .save-exit-btn:hover {
            background-color: #d32f2f;
        }
        .save-exit-btn:disabled {
            background-color: #ffcdd2;
            cursor: not-allowed;
        }
        /* Saving indicator */
        .saving-indicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            z-index: 2000;
            display: none;
        }
        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #4CAF50;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin-bottom: 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>Exercise Detection Demo</h1>
    
    <!-- Save and Exit Button -->
    <button id="saveExitBtn" class="save-exit-btn">Save & Exit</button>
    
    <!-- Saving Indicator -->
    <div id="savingIndicator" class="saving-indicator">
        <div class="spinner"></div>
        <p>Saving your progress...</p>
    </div>
    
    <div class="container">
        <div class="loading" id="loading">
            <p>Loading TensorFlow.js...</p>
        </div>
        
        <div class="user-info">
            <input type="text" id="usernameInput" placeholder="Enter your username" style="padding: 8px; width: 200px; margin-right: 10px;">
            <button id="setUsernameBtn">Set Username</button>
            
            <div class="level-display">
                Level <span id="levelDisplay">1</span>
            </div>
            
            <div class="xp-text">XP: <span id="xpDisplay">0</span> / <span id="xpNextLevel">100</span></div>
            <div class="xp-bar">
                <div class="xp-progress" id="xpProgress"></div>
            </div>
            
            <div class="milestone" id="milestone">
                Achievement Unlocked!
            </div>
        </div>
        
        <div class="model-selector">
            <label for="modelSelect">Select Exercise Type:</label>
            <select id="modelSelect">
                <option value="squat">Squat Detection</option>
                <option value="pushup">Push-up Detection</option>
                <option value="bicep">Bicep Curl Detection</option>
            </select>
            
            <div class="arm-selector" id="armSelector" style="display: none;">
                <label for="armSelect">Select Arm:</label>
                <select id="armSelect">
                    <option value="right">Right Arm</option>
                    <option value="left">Left Arm</option>
                    <option value="both">Both Arms</option>
                </select>
            </div>
        </div>
        
        <div class="video-container">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="output"></canvas>
            <div class="feedback-overlay" id="feedbackOverlay"></div>
        </div>
        
        <div class="controls">
            <button id="startBtn">Start Camera</button>
            <button id="detectBtn" disabled>Detect Exercise</button>
            <button id="stopBtn" disabled>Stop</button>
            <button id="resetBtn" disabled>Reset Counter</button>
        </div>
        
        <div class="results">
            <div class="exercise-status" id="exerciseStatus">Not detecting</div>
            <div>
                <p>Exercise detected:</p>
                <p id="detectedExercise">None</p>
            </div>
            <div>
                <p>Repetition count:</p>
                <div class="rep-counter" id="repCount">0</div>
            </div>
            <div id="formFeedback"></div>
            <div id="confidenceDisplay"></div>
            <div class="debug-info" id="debugInfo"></div>
        </div>
        
        <div class="leaderboard-export">
            <h3>Leaderboard Data</h3>
            <p>Username: <span id="leaderboardUsername">Not set</span></p>
            <p>Total XP: <span id="leaderboardXP">0</span></p>
            <p>Level: <span id="leaderboardLevel">1</span></p>
            <p>Exercises Completed Today: <span id="exercisesToday">0</span></p>
            <button id="exportDataBtn">Export Leaderboard Data</button>
        </div>
    </div>
    
    <div class="achievement" id="achievementNotification">
        <div class="achievement-title">Achievement Unlocked!</div>
        <div class="achievement-text" id="achievementText"></div>
    </div>

    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.20.0"></script>
    
    <!-- Load MoveNet model (newer and more accurate than PoseNet) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.0.0"></script>
    
    <script>
        // App state management (easier to port to React)
        const state = {
            model: null,
            detector: null,
            isModelLoaded: false,
            isDetecting: false,
            stream: null,
            animationId: null,
            currentExercise: "None",
            selectedExerciseType: "squat",
            selectedArm: "right",
            reps: 0,
            lastPoseState: "unknown",
            poseHistory: [],
            confidenceThreshold: 0.25,
            debugMode: true,  // Enable debug mode to help troubleshoot
            
            // XP System
            username: "Anonymous",
            xp: 0,
            level: 1,
            exercisesToday: 0,
            achievements: [],
            
            // Form quality tracking
            formQuality: {
                good: 0,
                poor: 0
            },
            formFeedback: "",
            streakCount: 0,
            lastRepTimestamp: 0,
            
            // Save and Exit state
            isSaving: false
        };

        // XP constants
        const XP_PER_REP = 10;
        const XP_FORM_BONUS = 5;
        const XP_STREAK_BONUS = 2;  // Multiplier for consecutive reps
        const XP_PER_LEVEL = 100;   // Base XP needed per level (increases with level)
        
        // Achievement definitions
        const achievements = [
            { id: "first_rep", name: "First Step", description: "Complete your first rep", xpReward: 25, triggered: false },
            { id: "level_up", name: "Level Up!", description: "Reach level 2", xpReward: 50, triggered: false },
            { id: "rep_10", name: "Dedicated", description: "Complete 10 reps in one session", xpReward: 100, triggered: false },
            { id: "rep_25", name: "Committed", description: "Complete 25 reps in one session", xpReward: 250, triggered: false },
            { id: "perfect_form", name: "Perfect Form", description: "Complete 5 reps with perfect form", xpReward: 150, triggered: false },
            { id: "exercise_variety", name: "Variety Pack", description: "Try all exercise types", xpReward: 200, triggered: false },
            { id: "streak_5", name: "On Fire!", description: "Complete 5 reps in quick succession", xpReward: 75, triggered: false }
        ];

        // DOM elements
        const elements = {
            video: document.getElementById('webcam'),
            canvas: document.getElementById('output'),
            startBtn: document.getElementById('startBtn'),
            detectBtn: document.getElementById('detectBtn'),
            stopBtn: document.getElementById('stopBtn'),
            resetBtn: document.getElementById('resetBtn'),
            loading: document.getElementById('loading'),
            exerciseStatus: document.getElementById('exerciseStatus'),
            detectedExercise: document.getElementById('detectedExercise'),
            repCount: document.getElementById('repCount'),
            modelSelect: document.getElementById('modelSelect'),
            armSelector: document.getElementById('armSelector'),
            armSelect: document.getElementById('armSelect'),
            confidenceDisplay: document.getElementById('confidenceDisplay'),
            debugInfo: document.getElementById('debugInfo'),
            feedbackOverlay: document.getElementById('feedbackOverlay'),
            formFeedback: document.getElementById('formFeedback'),
            
            // XP and User elements
            usernameInput: document.getElementById('usernameInput'),
            setUsernameBtn: document.getElementById('setUsernameBtn'),
            xpDisplay: document.getElementById('xpDisplay'),
            xpNextLevel: document.getElementById('xpNextLevel'),
            xpProgress: document.getElementById('xpProgress'),
            levelDisplay: document.getElementById('levelDisplay'),
            milestone: document.getElementById('milestone'),
            
            // Leaderboard elements
            leaderboardUsername: document.getElementById('leaderboardUsername'),
            leaderboardXP: document.getElementById('leaderboardXP'),
            leaderboardLevel: document.getElementById('leaderboardLevel'),
            exercisesToday: document.getElementById('exercisesToday'),
            exportDataBtn: document.getElementById('exportDataBtn'),
            
            // Achievement notification
            achievementNotification: document.getElementById('achievementNotification'),
            achievementText: document.getElementById('achievementText'),
            
            // Save and Exit elements
            saveExitBtn: document.getElementById('saveExitBtn'),
            savingIndicator: document.getElementById('savingIndicator')
        };
        
        let ctx;

        // Initialize the application
        async function init() {
            console.log("Initializing application...");
            
            // Initialize canvas context
            ctx = elements.canvas.getContext('2d');
            
            // Debug info update
            updateDebugInfo("Application initializing...");
            
            // Listen for messages from parent window
            window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'initUser') {
                    // Initialize user data from parent window
                    const userData = event.data.data;
                    state.username = userData.username;
                    state.xp = userData.xp;
                    state.level = userData.level;
                    
                    // Update UI
                    elements.usernameInput.value = state.username;
                    elements.leaderboardUsername.textContent = state.username;
                    elements.xpDisplay.textContent = state.xp;
                    elements.leaderboardXP.textContent = state.xp;
                    elements.levelDisplay.textContent = state.level;
                    elements.leaderboardLevel.textContent = state.level;
                    
                    // Calculate XP required for next level
                    const xpForNextLevel = XP_PER_LEVEL * state.level * 1.5;
                    elements.xpNextLevel.textContent = Math.ceil(xpForNextLevel);
                    
                    // Calculate progress percentage for XP bar
                    const progressPercentage = Math.min((state.xp / xpForNextLevel) * 100, 100);
                    elements.xpProgress.style.width = progressPercentage + "%";
                    
                    updateDebugInfo("User data received from parent window");
                }
                
                if (event.data && event.data.type === 'getFinalStats') {
                    // Send final stats to parent window
                    sendStatsToParent();
                }
            });
            
            // Load TensorFlow.js
            try {
                await tf.ready();
                console.log("TensorFlow.js is ready");
                elements.loading.innerHTML = "<p>TensorFlow.js loaded. Loading pose detection model...</p>";
                updateDebugInfo("TensorFlow.js loaded successfully");
                
                // Load the model
                await loadModel();
                
                // Set up event listeners
                setupEventListeners();
                
                // Load user data from localStorage if available
                loadUserData();
                
                elements.loading.style.display = "none";
            } catch (error) {
                console.error("Error initializing application:", error);
                elements.loading.innerHTML = "<p>Error initializing TensorFlow.js. Please try refreshing the page.</p>";
                updateDebugInfo("Error: " + error.message);
            }
        }

        // Send stats to parent window
        function sendStatsToParent() {
            const statsData = {
                username: state.username,
                xp: state.xp,
                level: state.level,
                reps: state.reps,
                exercisesToday: state.exercisesToday,
                formQuality: state.formQuality,
                formFeedback: state.formFeedback,
                exerciseType: state.selectedExerciseType,
                achievements: state.achievements
            };
            
            window.parent.postMessage({
                type: 'exerciseData',
                data: statsData
            }, '*');
            
            updateDebugInfo("Stats sent to parent window");
        }

        // Load the pose detection model
        async function loadModel() {
            try {
                updateDebugInfo("Loading MoveNet model...");
                
                // Use MoveNet - a newer and more efficient model than PoseNet
                const detectorConfig = {
                    modelType: poseDetection.movenet.modelType.SINGLEPOSE_LIGHTNING,
                    enableSmoothing: true
                };
                
                state.detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.MoveNet, 
                    detectorConfig
                );
                
                console.log("Model loaded successfully");
                updateDebugInfo("MoveNet model loaded successfully");
                state.isModelLoaded = true;
                return true;
            } catch (error) {
                console.error("Error loading model:", error);
                elements.loading.innerHTML = "<p>Error loading pose detection model. Please check your internet connection and try again.</p>";
                updateDebugInfo("Error loading model: " + error.message);
                return false;
            }
        }

        // Helper to update debug info
        function updateDebugInfo(message) {
            if (!state.debugMode) return;
            
            const timestamp = new Date().toLocaleTimeString();
            const debugMsg = `[${timestamp}] ${message}`;
            console.log(debugMsg);
            
            if (elements.debugInfo) {
                elements.debugInfo.innerHTML += debugMsg + "<br>";
                elements.debugInfo.scrollTop = elements.debugInfo.scrollHeight;
            }
        }

        // Set up event listeners
        function setupEventListeners() {
            // Start camera button
            elements.startBtn.addEventListener('click', startCamera);
            
            // Detect exercise button
            elements.detectBtn.addEventListener('click', startDetection);
            
            // Stop detection button
            elements.stopBtn.addEventListener('click', stopDetection);
            
            // Reset counter button
            elements.resetBtn.addEventListener('click', resetCounter);
            
            // Model selection
            elements.modelSelect.addEventListener('change', (e) => {
                state.selectedExerciseType = e.target.value;
                
                // Show/hide arm selector for bicep curls
                if (state.selectedExerciseType === 'bicep') {
                    elements.armSelector.style.display = 'block';
                } else {
                    elements.armSelector.style.display = 'none';
                }
                
                resetCounter();
                updateDebugInfo("Selected exercise type: " + state.selectedExerciseType);
                
                // Check for exercise variety achievement
                checkExerciseVarietyAchievement();
            });
            
            // Arm selection for bicep curls
            elements.armSelect.addEventListener('change', (e) => {
                state.selectedArm = e.target.value;
                resetCounter();
                updateDebugInfo("Selected arm: " + state.selectedArm);
            });
            
            // Username setting
            elements.setUsernameBtn.addEventListener('click', () => {
                const username = elements.usernameInput.value.trim();
                if (username) {
                    state.username = username;
                    elements.leaderboardUsername.textContent = username;
                    saveUserData();
                    updateDebugInfo("Username set to: " + username);
                }
            });
            
            // Export leaderboard data
            elements.exportDataBtn.addEventListener('click', exportLeaderboardData);
            
            // Save and Exit button
            elements.saveExitBtn.addEventListener('click', saveAndExit);
        }

        // Save and Exit function
        async function saveAndExit() {
    if (state.isSaving) return;
    
    state.isSaving = true;
    elements.saveExitBtn.disabled = true;
    elements.saveExitBtn.textContent = "Saving...";
    elements.savingIndicator.style.display = "flex";

    try {
        stopDetection();
        if (state.stream) {
            state.stream.getTracks().forEach(track => track.stop());
            state.stream = null;
        }

        // Create leaderboard entry
        const newEntry = {
            id: state.username,
            username: state.username,
            xp: state.xp,
            level: state.level,
            avatar: ""
        };

        // Fetch leaderboard from localStorage and update it
        let leaderboard = JSON.parse(localStorage.getItem("leaderboardData")) || [];
        const existingIndex = leaderboard.findIndex(entry => entry.username === state.username);
        
        if (existingIndex !== -1) {
            leaderboard[existingIndex] = newEntry;
        } else {
            leaderboard.push(newEntry);
        }

        // Sort leaderboard by XP
        leaderboard.sort((a, b) => b.xp - a.xp);
        
        // Store updated leaderboard
        localStorage.setItem("leaderboardData", JSON.stringify(leaderboard));

        // Notify parent (React page) to refresh leaderboard
        window.parent.postMessage({
            type: 'updateLeaderboard',
            data: newEntry
        }, '*');

        // Small delay to simulate saving process
        setTimeout(() => {
            window.location.href = "/leaderboard";  // Redirect to the leaderboard page
        }, 1000);

    } catch (error) {
        console.error("Error during save and exit:", error);
        alert("Error saving progress. Please try again.");
    }
}


        // Start the webcam
        async function startCamera() {
            try {
                updateDebugInfo("Starting camera...");
                
                state.stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 640,
                        height: 480
                    },
                    audio: false
                });
                
                elements.video.srcObject = state.stream;
                
                // Wait for video to be ready
                elements.video.onloadedmetadata = () => {
                    elements.canvas.width = elements.video.videoWidth;
                    elements.canvas.height = elements.video.videoHeight;
                    
                    // Ensure canvas is positioned correctly
                    elements.canvas.style.width = elements.video.videoWidth + "px";
                    elements.canvas.style.height = elements.video.videoHeight + "px";
                    
                    elements.startBtn.disabled = true;
                    elements.detectBtn.disabled = false;
                    updateDebugInfo("Camera started. Video dimensions: " + 
                                  elements.video.videoWidth + "x" + elements.video.videoHeight);
                };
            } catch (error) {
                console.error("Error accessing webcam:", error);
                alert("Error accessing webcam. Please ensure you have a webcam connected and have granted permission.");
                updateDebugInfo("Error accessing webcam: " + error.message);
            }
        }

        // Start pose detection
        function startDetection() {
            if (!state.isModelLoaded) {
                alert("Model is not loaded yet. Please wait.");
                return;
            }
            
            state.isDetecting = true;
            elements.detectBtn.disabled = true;
            elements.stopBtn.disabled = false;
            elements.resetBtn.disabled = false;
            elements.exerciseStatus.textContent = "Detecting...";
            
            updateDebugInfo("Starting detection for: " + state.selectedExerciseType);
            
            // Start detection loop
            detectPoses();
        }

        // Stop pose detection
        function stopDetection() {
            state.isDetecting = false;
            
            if (state.animationId) {
                cancelAnimationFrame(state.animationId);
            }
            
            elements.detectBtn.disabled = false;
            elements.stopBtn.disabled = true;
            elements.exerciseStatus.textContent = "Not detecting";
            
            // Clear canvas
            ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
            updateDebugInfo("Detection stopped");
            
            // Send stats to parent window
            sendStatsToParent();
        }
        
        // Reset rep counter
        function resetCounter() {
            state.reps = 0;
            elements.repCount.textContent = "0";
            state.lastPoseState = "unknown";
            state.poseHistory = [];
            state.formQuality = { good: 0, poor: 0 };
            state.streakCount = 0;
            state.formFeedback = "";
            elements.formFeedback.textContent = "";
            updateDebugInfo("Counter reset");
        }

        // Main detection loop
        async function detectPoses() {
            if (!state.isDetecting) return;
            
            try {
                // Detect poses
                const poses = await state.detector.estimatePoses(elements.video);
                
                // Clear canvas
                ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
                
                // If poses detected
                if (poses && poses.length > 0) {
                    const pose = poses[0]; // Use the first detected person
                    
                    // Draw skeleton
                    drawSkeleton(pose);
                    
                    // Store pose for smoothing
                    state.poseHistory.push(pose);
                    if (state.poseHistory.length > 5) {
                        state.poseHistory.shift();
                    }
                    
                    // Analyze pose to detect exercise
                    analyzeExercise(pose);
                } else {
                    updateDebugInfo("No poses detected in this frame");
                }
                
                // Continue detection loop
                state.animationId = requestAnimationFrame(detectPoses);
            } catch (error) {
                console.error("Error during pose detection:", error);
                elements.exerciseStatus.textContent = "Error detecting";
                state.isDetecting = false;
                updateDebugInfo("Detection error: " + error.message);
            }
        }

        // Draw the skeleton on canvas
        function drawSkeleton(pose) {
            if (!pose || !pose.keypoints) {
                updateDebugInfo("No keypoints to draw");
                return;
            }
            
            const keypoints = pose.keypoints;
            
            // Log keypoints for debugging
            if (state.debugMode) {
                const visibleKeypoints = keypoints.filter(kp => kp.score > state.confidenceThreshold).length;
                updateDebugInfo(`Drawing ${visibleKeypoints}/${keypoints.length} keypoints`);
            }
            
            // Draw keypoints
            keypoints.forEach(keypoint => {
                if (keypoint.score > state.confidenceThreshold) {
                    ctx.beginPath();
                    ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
                    ctx.fillStyle = 'aqua';
                    ctx.fill();
                    
                    // Display keypoint names for better debugging
                    ctx.fillStyle = 'white';
                    ctx.font = '10px Arial';
                    ctx.fillText(keypoint.name, keypoint.x + 7, keypoint.y - 3);
                }
            });
            
            // Define connections for skeleton
            const connections = [
                ['nose', 'left_eye'], ['left_eye', 'left_ear'], ['nose', 'right_eye'],
                ['right_eye', 'right_ear'], ['left_shoulder', 'right_shoulder'],
                ['left_shoulder', 'left_elbow'], ['left_elbow', 'left_wrist'],
                ['right_shoulder', 'right_elbow'], ['right_elbow', 'right_wrist'],
                ['left_shoulder', 'left_hip'], ['right_shoulder', 'right_hip'],
                ['left_hip', 'right_hip'], ['left_hip', 'left_knee'],
                ['left_knee', 'left_ankle'], ['right_hip', 'right_knee'],
                ['right_knee', 'right_ankle']
            ];
            
            // Draw connections
            ctx.strokeStyle = 'lime';
            ctx.lineWidth = 2;
            
            connections.forEach(([p1Name, p2Name]) => {
                const p1 = keypoints.find(kp => kp.name === p1Name);
                const p2 = keypoints.find(kp => kp.name === p2Name);
                
                if (p1 && p2 && p1.score > state.confidenceThreshold && p2.score > state.confidenceThreshold) {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            });
            
            // Display confidence
            const avgConfidence = keypoints.reduce((sum, kp) => sum + kp.score, 0) / keypoints.length;
            elements.confidenceDisplay.innerHTML = `<p>Pose detection confidence: ${(avgConfidence * 100).toFixed(1)}%</p>`;
        }

        // Analyze pose to detect exercises
        function analyzeExercise(pose) {
            if (!pose || !pose.keypoints) {
                updateDebugInfo("No keypoints for exercise analysis");
                return;
            }
            
            const keypointMap = {};
            pose.keypoints.forEach(kp => {
                keypointMap[kp.name] = {
                    x: kp.x,
                    y: kp.y,
                    score: kp.score
                };
            });
            
            // Call the appropriate exercise detection based on selection
            switch (state.selectedExerciseType) {
                case 'squat':
                    detectSquat(keypointMap);
                    break;
                case 'pushup':
                    detectPushup(keypointMap);
                    break;
                case 'bicep':
                    detectBicepCurl(keypointMap);
                    break;
                default:
                    detectSquat(keypointMap);
            }
            
            // Update UI
            elements.detectedExercise.textContent = state.currentExercise;
            
            // Update form feedback
            updateFormFeedback();
            
            // Send stats to parent window periodically
            if (state.reps > 0 && state.reps % 5 === 0) {
                sendStatsToParent();
            }
        }

        // Detect squats
        function detectSquat(keypoints) {
            const leftHip = keypoints['left_hip'];
            const rightHip = keypoints['right_hip'];
            const leftKnee = keypoints['left_knee'];
            const rightKnee = keypoints['right_knee'];
            const leftAnkle = keypoints['left_ankle'];
            const rightAnkle = keypoints['right_ankle'];
            const leftShoulder = keypoints['left_shoulder'];
            const rightShoulder = keypoints['right_shoulder'];
            
            // Check if key points are detected with sufficient confidence
            if (
                leftHip && rightHip && leftKnee && rightKnee && leftAnkle && rightAnkle &&
                leftHip.score > state.confidenceThreshold && rightHip.score > state.confidenceThreshold &&
                leftKnee.score > state.confidenceThreshold && rightKnee.score > state.confidenceThreshold &&
                leftAnkle.score > state.confidenceThreshold && rightAnkle.score > state.confidenceThreshold
            ) {
                // Calculate hip height relative to knees
                const hipHeight = (leftHip.y + rightHip.y) / 2;
                const kneeHeight = (leftKnee.y + rightKnee.y) / 2;
                const ankleHeight = (leftAnkle.y + rightAnkle.y) / 2;
                
                // Calculate angle at knee for more accurate squat detection
                const kneeAngle = calculateAngle(
                    [(leftHip.x + rightHip.x) / 2, (leftHip.y + rightHip.y) / 2],
                    [(leftKnee.x + rightKnee.x) / 2, (leftKnee.y + rightKnee.y) / 2],
                    [(leftAnkle.x + rightAnkle.x) / 2, (leftAnkle.y + rightAnkle.y) / 2]
                );
                
                // Calculate back angle (for form checking)
                const backAngle = Math.abs(90 - calculateAngle(
                    [(leftShoulder.x + rightShoulder.x) / 2, (leftShoulder.y + rightShoulder.y) / 2],
                    [(leftHip.x + rightHip.x) / 2, (leftHip.y + rightHip.y) / 2],
                    [(leftHip.x + rightHip.x) / 2, (leftHip.y + rightHip.y) / 2 - 100] // Vertical reference
                ));
                
                // Display angles for debugging
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(`Knee angle: ${kneeAngle.toFixed(1)}°`, 10, 30);
                ctx.fillText(`Back angle: ${backAngle.toFixed(1)}°`, 10, 50);
                
                updateDebugInfo(`Squat knee angle: ${kneeAngle.toFixed(1)}°, back angle: ${backAngle.toFixed(1)}°`);
                
                // Check form quality
                let formQuality = "good";
                if (kneeAngle < 80) {
                    // Knees too bent (could be bad for knees)
                    formQuality = "poor";
                    state.formFeedback = "Avoid going too low in your squat";
                } else if (backAngle > 30) {
                    // Back leaning forward too much
                    formQuality = "poor";
                    state.formFeedback = "Keep your back more upright";
                } else {
                    state.formFeedback = "Good form!";
                }
                
                // Use knee angle for detection
                if (kneeAngle < 120) { // Person is in squat position
                    // Show feedback overlay
                    showFeedbackOverlay(formQuality);
                    
                    if (state.lastPoseState === "standing") {
                        // Transition from standing to squatting - count a rep
                        countRep(formQuality);
                    }
                    state.lastPoseState = "squatting";
                    state.currentExercise = "Squat";
                } else {
                    // Person is in standing position
                    elements.feedbackOverlay.style.opacity = "0";
                    state.lastPoseState = "standing";
                }
            } else {
                updateDebugInfo("Critical keypoints for squat detection are not visible");
            }
        }

        // Detect push-ups
        function detectPushup(keypoints) {
            const leftShoulder = keypoints['left_shoulder'];
            const rightShoulder = keypoints['right_shoulder'];
            const leftElbow = keypoints['left_elbow'];
            const rightElbow = keypoints['right_elbow'];
            const leftWrist = keypoints['left_wrist'];
            const rightWrist = keypoints['right_wrist'];
            const leftHip = keypoints['left_hip'];
            const rightHip = keypoints['right_hip'];
            
            // Check if key points are detected with sufficient confidence
            if (
                leftShoulder && rightShoulder && leftElbow && rightElbow && leftWrist && rightWrist &&
                leftShoulder.score > state.confidenceThreshold && rightShoulder.score > state.confidenceThreshold &&
                leftElbow.score > state.confidenceThreshold && rightElbow.score > state.confidenceThreshold &&
                leftWrist.score > state.confidenceThreshold && rightWrist.score > state.confidenceThreshold
            ) {
                // Calculate elbow angle
                const leftElbowAngle = calculateAngle(
                    [leftShoulder.x, leftShoulder.y],
                    [leftElbow.x, leftElbow.y],
                    [leftWrist.x, leftWrist.y]
                );
                
                const rightElbowAngle = calculateAngle(
                    [rightShoulder.x, rightShoulder.y],
                    [rightElbow.x, rightElbow.y],
                    [rightWrist.x, rightWrist.y]
                );
                
                // Average elbow angle
                const elbowAngle = (leftElbowAngle + rightElbowAngle) / 2;
                
                // Calculate body alignment (for form checking)
                let bodyAlignment = 0;
                if (leftHip && rightHip && 
                    leftHip.score > state.confidenceThreshold && rightHip.score > state.confidenceThreshold) {
                    // Check if body is straight (hips not sagging)
                    const shoulderHeight = (leftShoulder.y + rightShoulder.y) / 2;
                    const hipHeight = (leftHip.y + rightHip.y) / 2;
                    // Normalized height difference (smaller is better)
                    bodyAlignment = Math.abs(hipHeight - shoulderHeight) / elements.canvas.height;
                }
                
                // Display angles for debugging
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(`Elbow angle: ${elbowAngle.toFixed(1)}°`, 10, 30);
                ctx.fillText(`Body alignment: ${(bodyAlignment * 100).toFixed(1)}%`, 10, 50);
                
                updateDebugInfo(`Pushup elbow angle: ${elbowAngle.toFixed(1)}°, alignment: ${(bodyAlignment * 100).toFixed(1)}%`);
                
                // Check form quality
                let formQuality = "good";
                if (bodyAlignment > 0.15) {
                    // Hips sagging or raised too much
                    formQuality = "poor";
                    state.formFeedback = "Keep your body in a straight line";
                } else if (elbowAngle < 70) {
                    // Going too low
                    formQuality = "poor";
                    state.formFeedback = "Don't go too low, protect your shoulders";
                } else {
                    state.formFeedback = "Good form!";
                }
                
                // Use elbow angle for detection
                if (elbowAngle < 120) { // Arms bent - down position
                    // Show feedback overlay
                    showFeedbackOverlay(formQuality);
                    
                    if (state.lastPoseState === "up") {
                        // Transition from up to down - count a rep
                        countRep(formQuality);
                    }
                    state.lastPoseState = "down";
                    state.currentExercise = "Push-up";
                } else {
                    // Arms straight - up position
                    elements.feedbackOverlay.style.opacity = "0";
                    state.lastPoseState = "up";
                }
            } else {
                updateDebugInfo("Critical keypoints for pushup detection are not visible");
            }
        }

        // Detect bicep curls
        function detectBicepCurl(keypoints) {
            // Determine which arm to track based on selection
            let shoulderPoint, elbowPoint, wristPoint;
            let armSide = "";
            
            if (state.selectedArm === 'right' || state.selectedArm === 'both') {
                shoulderPoint = keypoints['right_shoulder'];
                elbowPoint = keypoints['right_elbow'];
                wristPoint = keypoints['right_wrist'];
                armSide = "right";
            } else {
                shoulderPoint = keypoints['left_shoulder'];
                elbowPoint = keypoints['left_elbow'];
                wristPoint = keypoints['left_wrist'];
                armSide = "left";
            }
            
            // Check if key points are detected
            if (
                shoulderPoint && elbowPoint && wristPoint &&
                shoulderPoint.score > state.confidenceThreshold && 
                elbowPoint.score > state.confidenceThreshold && 
                wristPoint.score > state.confidenceThreshold
            ) {
                // Calculate elbow angle
                const elbowAngle = calculateAngle(
                    [shoulderPoint.x, shoulderPoint.y],
                    [elbowPoint.x, elbowPoint.y],
                    [wristPoint.x, wristPoint.y]
                );
                
                // Display angle for debugging
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(`${armSide} elbow angle: ${elbowAngle.toFixed(1)}°`, 10, 30);
                
                updateDebugInfo(`Bicep curl ${armSide} elbow angle: ${elbowAngle.toFixed(1)}°`);
                
                // Check form quality
                let formQuality = "good";
                // Check if elbow is stable (not moving forward/backward too much)
                const shoulderX = shoulderPoint.x;
                const elbowX = elbowPoint.x;
                const elbowDeviation = Math.abs(elbowX - shoulderX) / elements.canvas.width;
                
                if (elbowDeviation > 0.15) {
                    // Elbow moving too much
                    formQuality = "poor";
                    state.formFeedback = "Keep your elbow close to your body";
                } else if (elbowAngle > 160) {
                    // Extending arm too much
                    formQuality = "poor";
                    state.formFeedback = "Don't fully extend your arm, keep tension";
                } else {
                    state.formFeedback = "Good form!";
                }
                
                // Use elbow angle for detection
                if (elbowAngle < 90) { // Arm bent - up position
                    // Show feedback overlay
                    showFeedbackOverlay(formQuality);
                    
                    if (state.lastPoseState === "down") {
                        // Transition from down to up - count a rep
                        countRep(formQuality);
                    }
                    state.lastPoseState = "up";
                    state.currentExercise = "Bicep Curl";
                } else if (elbowAngle > 130) {
                    // Arm extended - down position
                    elements.feedbackOverlay.style.opacity = "0";
                    state.lastPoseState = "down";
                }
                
                // If tracking both arms, check the other arm too
                if (state.selectedArm === 'both') {
                    const otherShoulder = keypoints['left_shoulder'];
                    const otherElbow = keypoints['left_elbow'];
                    const otherWrist = keypoints['left_wrist'];
                    
                    if (
                        otherShoulder && otherElbow && otherWrist &&
                        otherShoulder.score > state.confidenceThreshold && 
                        otherElbow.score > state.confidenceThreshold && 
                        otherWrist.score > state.confidenceThreshold
                    ) {
                        const otherElbowAngle = calculateAngle(
                            [otherShoulder.x, otherShoulder.y],
                            [otherElbow.x, otherElbow.y],
                            [otherWrist.x, otherWrist.y]
                        );
                        
                        updateDebugInfo(`Left elbow angle: ${otherElbowAngle.toFixed(1)}°`);
                        
                        // We'll count reps only from the right arm for simplicity
                    }
                }
            } else {
                updateDebugInfo("Critical keypoints for bicep curl detection are not visible");
            }
        }

        // Helper function to calculate angle between 3 points
        function calculateAngle(p1, p2, p3) {
            const [x1, y1] = p1;
            const [x2, y2] = p2;
            const [x3, y3] = p3;
            
            // Calculate vectors
            const v1x = x1 - x2;
            const v1y = y1 - y2;
            const v2x = x3 - x2;
            const v2y = y3 - y2;
            
            // Calculate dot product
            const dotProduct = v1x * v2x + v1y * v2y;
            
            // Calculate magnitudes
            const v1Mag = Math.sqrt(v1x * v1x + v1y * v1y);
            const v2Mag = Math.sqrt(v2x * v2x + v2y * v2y);
            
            // Calculate angle in radians
            const angleRad = Math.acos(dotProduct / (v1Mag * v2Mag));
            
            // Convert to degrees
            return angleRad * (180 / Math.PI);
        }

        // Count a repetition
        function countRep(formQuality) {
            state.reps++;
            elements.repCount.textContent = state.reps;
            
            // Record form quality
            if (formQuality === "good") {
                state.formQuality.good++;
            } else {
                state.formQuality.poor++;
            }
            
            // Check for streak (reps in quick succession)
            const now = Date.now();
            if (now - state.lastRepTimestamp < 3000) { // Within 3 seconds
                state.streakCount++;
                
                // Check for streak achievement
                if (state.streakCount === 5) {
                    unlockAchievement("streak_5");
                }
            } else {
                state.streakCount = 1;
            }
            state.lastRepTimestamp = now;
            
            // Award XP
            let xpEarned = XP_PER_REP;
            
            // Form quality bonus
            if (formQuality === "good") {
                xpEarned += XP_FORM_BONUS;
            }
            
            // Streak bonus
            if (state.streakCount > 1) {
                xpEarned *= (1 + (state.streakCount * 0.1)); // 10% extra per rep in streak
            }
            
            // Add XP
            addXP(Math.round(xpEarned));
            
            // Check for achievements
            if (state.reps === 1) {
                unlockAchievement("first_rep");
            } else if (state.reps === 10) {
                unlockAchievement("rep_10");
            } else if (state.reps === 25) {
                unlockAchievement("rep_25");
            }
            
            // Check for perfect form achievement
            if (state.formQuality.good >= 5 && state.formQuality.poor === 0) {
                unlockAchievement("perfect_form");
            }
            
            updateDebugInfo(`Rep counted! Total: ${state.reps}, XP earned: ${xpEarned}`);
            
            // Increment exercises today counter
            state.exercisesToday++;
            elements.exercisesToday.textContent = state.exercisesToday;
            
            // Save user data
            saveUserData();
            
            // Send stats to parent window
            sendStatsToParent();
        }

        // Add XP and check for level up
        function addXP(amount) {
            state.xp += amount;
            
            // Calculate XP required for next level
            // Formula: base XP × level × 1.5 (increasing difficulty)
            const xpForNextLevel = XP_PER_LEVEL * state.level * 1.5;
            
            // Check for level up
            if (state.xp >= xpForNextLevel) {
                state.level++;
                
                elements.levelDisplay.textContent = state.level;
                showMilestone(`Level up! You are now level ${state.level}`);
                
                // Check for level up achievement
                if (state.level === 2) {
                    unlockAchievement("level_up");
                }
            }
            
            // Update XP display
            elements.xpDisplay.textContent = state.xp;
            elements.leaderboardXP.textContent = state.xp;
            elements.leaderboardLevel.textContent = state.level;
            
            // Calculate progress percentage for XP bar
            const progressPercentage = Math.min((state.xp / xpForNextLevel) * 100, 100);
            elements.xpProgress.style.width = progressPercentage + "%";
            
            // Update XP required for next level
            elements.xpNextLevel.textContent = Math.ceil(xpForNextLevel);
        }

        // Show milestone notification
        function showMilestone(message) {
            elements.milestone.textContent = message;
            elements.milestone.style.display = "block";
            
            // Hide after 3 seconds
            setTimeout(() => {
                elements.milestone.style.display = "none";
            }, 3000);
        }

        // Unlock achievement
        function unlockAchievement(achievementId) {
            const achievement = achievements.find(a => a.id === achievementId);
            
            if (achievement && !achievement.triggered) {
                achievement.triggered = true;
                
                // Award XP bonus
                addXP(achievement.xpReward);
                
                // Show achievement notification
                elements.achievementText.textContent = `${achievement.name}: ${achievement.description}`;
                elements.achievementNotification.classList.add("show-achievement");
                
                // Hide notification after 5 seconds
                setTimeout(() => {
                    elements.achievementNotification.classList.remove("show-achievement");
                }, 5000);
                
                updateDebugInfo(`Achievement unlocked: ${achievement.name}`);
                
                // Save achievement
                state.achievements.push(achievementId);
                saveUserData();
                
                // Send stats to parent window
                sendStatsToParent();
            }
        }

        // Check for exercise variety achievement
        function checkExerciseVarietyAchievement() {
            // Create a set of tried exercise types if it doesn't exist
            if (!state.exercisesTried) {
                state.exercisesTried = new Set();
            }
            
            // Add current exercise type to set
            state.exercisesTried.add(state.selectedExerciseType);
            
            // Check if all exercise types have been tried
            if (state.exercisesTried.size >= 3) { // squat, pushup, bicep
                unlockAchievement("exercise_variety");
            }
        }

        // Show form feedback overlay
        function showFeedbackOverlay(quality) {
            const overlay = elements.feedbackOverlay;
            
            if (quality === "good") {
                overlay.textContent = "✓";
                overlay.className = "feedback-overlay correct-form";
            } else {
                overlay.textContent = "✗";
                overlay.className = "feedback-overlay incorrect-form";
            }
            
            overlay.style.opacity = "0.7";
        }

        // Update form feedback in UI
        function updateFormFeedback() {
            elements.formFeedback.textContent = state.formFeedback;
        }

        // Save user data to localStorage
        function saveUserData() {
            const userData = {
                username: state.username,
                xp: state.xp,
                level: state.level,
                exercisesToday: state.exercisesToday,
                achievements: state.achievements,
                exercisesTried: Array.from(state.exercisesTried || []),
                lastSaved: new Date().toISOString()
            };
            
            try {
                localStorage.setItem('exerciseDetectionUserData', JSON.stringify(userData));
                updateDebugInfo("User data saved to localStorage");
            } catch (error) {
                console.error("Error saving user data:", error);
                updateDebugInfo("Error saving user data: " + error.message);
            }
        }

        // Load user data from localStorage
        function loadUserData() {
            try {
                const savedData = localStorage.getItem('exerciseDetectionUserData');
                
                if (savedData) {
                    const userData = JSON.parse(savedData);
                    
                    // Check if data is from a different day, reset daily counters
                    const lastSaved = new Date(userData.lastSaved);
                    const today = new Date();
                    const isSameDay = lastSaved.getDate() === today.getDate() && 
                                     lastSaved.getMonth() === today.getMonth() && 
                                     lastSaved.getFullYear() === today.getFullYear();
                    
                    if (!isSameDay) {
                        userData.exercisesToday = 0;
                    }
                    
                    // Update state with saved data
                    state.username = userData.username || "Anonymous";
                    state.xp = userData.xp || 0;
                    state.level = userData.level || 1;
                    state.exercisesToday = userData.exercisesToday || 0;
                    state.achievements = userData.achievements || [];
                    state.exercisesTried = new Set(userData.exercisesTried || []);
                    
                    // Update UI
                    elements.usernameInput.value = state.username;
                    elements.leaderboardUsername.textContent = state.username;
                    elements.xpDisplay.textContent = state.xp;
                    elements.leaderboardXP.textContent = state.xp;
                    elements.levelDisplay.textContent = state.level;
                    elements.leaderboardLevel.textContent = state.level;
                    elements.exercisesToday.textContent = state.exercisesToday;
                    
                    // Calculate XP required for next level
                    const xpForNextLevel = XP_PER_LEVEL * state.level * 1.5;
                    elements.xpNextLevel.textContent = Math.ceil(xpForNextLevel);
                    
                    // Calculate progress percentage for XP bar
                    const progressPercentage = Math.min((state.xp / xpForNextLevel) * 100, 100);
                    elements.xpProgress.style.width = progressPercentage + "%";
                    
                    updateDebugInfo("User data loaded from localStorage");
                }
            } catch (error) {
                console.error("Error loading user data:", error);
                updateDebugInfo("Error loading user data: " + error.message);
            }
        }

        // Export leaderboard data
        function exportLeaderboardData() {
            const data = {
                username: state.username,
                totalXP: state.xp,
                level: state.level,
                exercisesToday: state.exercisesToday,
                achievements: state.achievements,
                exportDate: new Date().toISOString()
            };
            
            // Create a data URL for the JSON
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data, null, 2));
            
            // Create a download link
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", `fitness_data_${state.username}.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            
            updateDebugInfo("Leaderboard data exported");
        }

        // Initialize application on load
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>